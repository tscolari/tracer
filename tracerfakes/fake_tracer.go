// Code generated by counterfeiter. DO NOT EDIT.
package tracerfakes

import (
	"sync"

	"github.com/tscolari/tracer"
)

type FakeTracer struct {
	StartTransactionStub        func(id string)
	startTransactionMutex       sync.RWMutex
	startTransactionArgsForCall []struct {
		id string
	}
	StartSpanStub        func(id string) tracer.Tracer
	startSpanMutex       sync.RWMutex
	startSpanArgsForCall []struct {
		id string
	}
	startSpanReturns struct {
		result1 tracer.Tracer
	}
	startSpanReturnsOnCall map[int]struct {
		result1 tracer.Tracer
	}
	EndStub        func() error
	endMutex       sync.RWMutex
	endArgsForCall []struct{}
	endReturns     struct {
		result1 error
	}
	endReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTracer) StartTransaction(id string) {
	fake.startTransactionMutex.Lock()
	fake.startTransactionArgsForCall = append(fake.startTransactionArgsForCall, struct {
		id string
	}{id})
	fake.recordInvocation("StartTransaction", []interface{}{id})
	fake.startTransactionMutex.Unlock()
	if fake.StartTransactionStub != nil {
		fake.StartTransactionStub(id)
	}
}

func (fake *FakeTracer) StartTransactionCallCount() int {
	fake.startTransactionMutex.RLock()
	defer fake.startTransactionMutex.RUnlock()
	return len(fake.startTransactionArgsForCall)
}

func (fake *FakeTracer) StartTransactionArgsForCall(i int) string {
	fake.startTransactionMutex.RLock()
	defer fake.startTransactionMutex.RUnlock()
	return fake.startTransactionArgsForCall[i].id
}

func (fake *FakeTracer) StartSpan(id string) tracer.Tracer {
	fake.startSpanMutex.Lock()
	ret, specificReturn := fake.startSpanReturnsOnCall[len(fake.startSpanArgsForCall)]
	fake.startSpanArgsForCall = append(fake.startSpanArgsForCall, struct {
		id string
	}{id})
	fake.recordInvocation("StartSpan", []interface{}{id})
	fake.startSpanMutex.Unlock()
	if fake.StartSpanStub != nil {
		return fake.StartSpanStub(id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.startSpanReturns.result1
}

func (fake *FakeTracer) StartSpanCallCount() int {
	fake.startSpanMutex.RLock()
	defer fake.startSpanMutex.RUnlock()
	return len(fake.startSpanArgsForCall)
}

func (fake *FakeTracer) StartSpanArgsForCall(i int) string {
	fake.startSpanMutex.RLock()
	defer fake.startSpanMutex.RUnlock()
	return fake.startSpanArgsForCall[i].id
}

func (fake *FakeTracer) StartSpanReturns(result1 tracer.Tracer) {
	fake.StartSpanStub = nil
	fake.startSpanReturns = struct {
		result1 tracer.Tracer
	}{result1}
}

func (fake *FakeTracer) StartSpanReturnsOnCall(i int, result1 tracer.Tracer) {
	fake.StartSpanStub = nil
	if fake.startSpanReturnsOnCall == nil {
		fake.startSpanReturnsOnCall = make(map[int]struct {
			result1 tracer.Tracer
		})
	}
	fake.startSpanReturnsOnCall[i] = struct {
		result1 tracer.Tracer
	}{result1}
}

func (fake *FakeTracer) End() error {
	fake.endMutex.Lock()
	ret, specificReturn := fake.endReturnsOnCall[len(fake.endArgsForCall)]
	fake.endArgsForCall = append(fake.endArgsForCall, struct{}{})
	fake.recordInvocation("End", []interface{}{})
	fake.endMutex.Unlock()
	if fake.EndStub != nil {
		return fake.EndStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.endReturns.result1
}

func (fake *FakeTracer) EndCallCount() int {
	fake.endMutex.RLock()
	defer fake.endMutex.RUnlock()
	return len(fake.endArgsForCall)
}

func (fake *FakeTracer) EndReturns(result1 error) {
	fake.EndStub = nil
	fake.endReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTracer) EndReturnsOnCall(i int, result1 error) {
	fake.EndStub = nil
	if fake.endReturnsOnCall == nil {
		fake.endReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTracer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.startTransactionMutex.RLock()
	defer fake.startTransactionMutex.RUnlock()
	fake.startSpanMutex.RLock()
	defer fake.startSpanMutex.RUnlock()
	fake.endMutex.RLock()
	defer fake.endMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTracer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ tracer.Tracer = new(FakeTracer)
