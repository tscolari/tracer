// This file was generated by counterfeiter
package opentracingfakes

import (
	"sync"

	opentracing "github.com/opentracing/opentracing-go"
	"github.com/opentracing/opentracing-go/log"
)

type FakeSpan struct {
	FinishStub                   func()
	finishMutex                  sync.RWMutex
	finishArgsForCall            []struct{}
	FinishWithOptionsStub        func(opts opentracing.FinishOptions)
	finishWithOptionsMutex       sync.RWMutex
	finishWithOptionsArgsForCall []struct {
		opts opentracing.FinishOptions
	}
	ContextStub        func() opentracing.SpanContext
	contextMutex       sync.RWMutex
	contextArgsForCall []struct{}
	contextReturns     struct {
		result1 opentracing.SpanContext
	}
	contextReturnsOnCall map[int]struct {
		result1 opentracing.SpanContext
	}
	SetOperationNameStub        func(operationName string) opentracing.Span
	setOperationNameMutex       sync.RWMutex
	setOperationNameArgsForCall []struct {
		operationName string
	}
	setOperationNameReturns struct {
		result1 opentracing.Span
	}
	setOperationNameReturnsOnCall map[int]struct {
		result1 opentracing.Span
	}
	SetTagStub        func(key string, value interface{}) opentracing.Span
	setTagMutex       sync.RWMutex
	setTagArgsForCall []struct {
		key   string
		value interface{}
	}
	setTagReturns struct {
		result1 opentracing.Span
	}
	setTagReturnsOnCall map[int]struct {
		result1 opentracing.Span
	}
	LogFieldsStub        func(fields ...log.Field)
	logFieldsMutex       sync.RWMutex
	logFieldsArgsForCall []struct {
		fields []log.Field
	}
	LogKVStub        func(alternatingKeyValues ...interface{})
	logKVMutex       sync.RWMutex
	logKVArgsForCall []struct {
		alternatingKeyValues []interface{}
	}
	SetBaggageItemStub        func(restrictedKey, value string) opentracing.Span
	setBaggageItemMutex       sync.RWMutex
	setBaggageItemArgsForCall []struct {
		restrictedKey string
		value         string
	}
	setBaggageItemReturns struct {
		result1 opentracing.Span
	}
	setBaggageItemReturnsOnCall map[int]struct {
		result1 opentracing.Span
	}
	BaggageItemStub        func(restrictedKey string) string
	baggageItemMutex       sync.RWMutex
	baggageItemArgsForCall []struct {
		restrictedKey string
	}
	baggageItemReturns struct {
		result1 string
	}
	baggageItemReturnsOnCall map[int]struct {
		result1 string
	}
	TracerStub        func() opentracing.Tracer
	tracerMutex       sync.RWMutex
	tracerArgsForCall []struct{}
	tracerReturns     struct {
		result1 opentracing.Tracer
	}
	tracerReturnsOnCall map[int]struct {
		result1 opentracing.Tracer
	}
	LogEventStub        func(event string)
	logEventMutex       sync.RWMutex
	logEventArgsForCall []struct {
		event string
	}
	LogEventWithPayloadStub        func(event string, payload interface{})
	logEventWithPayloadMutex       sync.RWMutex
	logEventWithPayloadArgsForCall []struct {
		event   string
		payload interface{}
	}
	LogStub        func(data opentracing.LogData)
	logMutex       sync.RWMutex
	logArgsForCall []struct {
		data opentracing.LogData
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSpan) Finish() {
	fake.finishMutex.Lock()
	fake.finishArgsForCall = append(fake.finishArgsForCall, struct{}{})
	fake.recordInvocation("Finish", []interface{}{})
	fake.finishMutex.Unlock()
	if fake.FinishStub != nil {
		fake.FinishStub()
	}
}

func (fake *FakeSpan) FinishCallCount() int {
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	return len(fake.finishArgsForCall)
}

func (fake *FakeSpan) FinishWithOptions(opts opentracing.FinishOptions) {
	fake.finishWithOptionsMutex.Lock()
	fake.finishWithOptionsArgsForCall = append(fake.finishWithOptionsArgsForCall, struct {
		opts opentracing.FinishOptions
	}{opts})
	fake.recordInvocation("FinishWithOptions", []interface{}{opts})
	fake.finishWithOptionsMutex.Unlock()
	if fake.FinishWithOptionsStub != nil {
		fake.FinishWithOptionsStub(opts)
	}
}

func (fake *FakeSpan) FinishWithOptionsCallCount() int {
	fake.finishWithOptionsMutex.RLock()
	defer fake.finishWithOptionsMutex.RUnlock()
	return len(fake.finishWithOptionsArgsForCall)
}

func (fake *FakeSpan) FinishWithOptionsArgsForCall(i int) opentracing.FinishOptions {
	fake.finishWithOptionsMutex.RLock()
	defer fake.finishWithOptionsMutex.RUnlock()
	return fake.finishWithOptionsArgsForCall[i].opts
}

func (fake *FakeSpan) Context() opentracing.SpanContext {
	fake.contextMutex.Lock()
	ret, specificReturn := fake.contextReturnsOnCall[len(fake.contextArgsForCall)]
	fake.contextArgsForCall = append(fake.contextArgsForCall, struct{}{})
	fake.recordInvocation("Context", []interface{}{})
	fake.contextMutex.Unlock()
	if fake.ContextStub != nil {
		return fake.ContextStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.contextReturns.result1
}

func (fake *FakeSpan) ContextCallCount() int {
	fake.contextMutex.RLock()
	defer fake.contextMutex.RUnlock()
	return len(fake.contextArgsForCall)
}

func (fake *FakeSpan) ContextReturns(result1 opentracing.SpanContext) {
	fake.ContextStub = nil
	fake.contextReturns = struct {
		result1 opentracing.SpanContext
	}{result1}
}

func (fake *FakeSpan) ContextReturnsOnCall(i int, result1 opentracing.SpanContext) {
	fake.ContextStub = nil
	if fake.contextReturnsOnCall == nil {
		fake.contextReturnsOnCall = make(map[int]struct {
			result1 opentracing.SpanContext
		})
	}
	fake.contextReturnsOnCall[i] = struct {
		result1 opentracing.SpanContext
	}{result1}
}

func (fake *FakeSpan) SetOperationName(operationName string) opentracing.Span {
	fake.setOperationNameMutex.Lock()
	ret, specificReturn := fake.setOperationNameReturnsOnCall[len(fake.setOperationNameArgsForCall)]
	fake.setOperationNameArgsForCall = append(fake.setOperationNameArgsForCall, struct {
		operationName string
	}{operationName})
	fake.recordInvocation("SetOperationName", []interface{}{operationName})
	fake.setOperationNameMutex.Unlock()
	if fake.SetOperationNameStub != nil {
		return fake.SetOperationNameStub(operationName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setOperationNameReturns.result1
}

func (fake *FakeSpan) SetOperationNameCallCount() int {
	fake.setOperationNameMutex.RLock()
	defer fake.setOperationNameMutex.RUnlock()
	return len(fake.setOperationNameArgsForCall)
}

func (fake *FakeSpan) SetOperationNameArgsForCall(i int) string {
	fake.setOperationNameMutex.RLock()
	defer fake.setOperationNameMutex.RUnlock()
	return fake.setOperationNameArgsForCall[i].operationName
}

func (fake *FakeSpan) SetOperationNameReturns(result1 opentracing.Span) {
	fake.SetOperationNameStub = nil
	fake.setOperationNameReturns = struct {
		result1 opentracing.Span
	}{result1}
}

func (fake *FakeSpan) SetOperationNameReturnsOnCall(i int, result1 opentracing.Span) {
	fake.SetOperationNameStub = nil
	if fake.setOperationNameReturnsOnCall == nil {
		fake.setOperationNameReturnsOnCall = make(map[int]struct {
			result1 opentracing.Span
		})
	}
	fake.setOperationNameReturnsOnCall[i] = struct {
		result1 opentracing.Span
	}{result1}
}

func (fake *FakeSpan) SetTag(key string, value interface{}) opentracing.Span {
	fake.setTagMutex.Lock()
	ret, specificReturn := fake.setTagReturnsOnCall[len(fake.setTagArgsForCall)]
	fake.setTagArgsForCall = append(fake.setTagArgsForCall, struct {
		key   string
		value interface{}
	}{key, value})
	fake.recordInvocation("SetTag", []interface{}{key, value})
	fake.setTagMutex.Unlock()
	if fake.SetTagStub != nil {
		return fake.SetTagStub(key, value)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setTagReturns.result1
}

func (fake *FakeSpan) SetTagCallCount() int {
	fake.setTagMutex.RLock()
	defer fake.setTagMutex.RUnlock()
	return len(fake.setTagArgsForCall)
}

func (fake *FakeSpan) SetTagArgsForCall(i int) (string, interface{}) {
	fake.setTagMutex.RLock()
	defer fake.setTagMutex.RUnlock()
	return fake.setTagArgsForCall[i].key, fake.setTagArgsForCall[i].value
}

func (fake *FakeSpan) SetTagReturns(result1 opentracing.Span) {
	fake.SetTagStub = nil
	fake.setTagReturns = struct {
		result1 opentracing.Span
	}{result1}
}

func (fake *FakeSpan) SetTagReturnsOnCall(i int, result1 opentracing.Span) {
	fake.SetTagStub = nil
	if fake.setTagReturnsOnCall == nil {
		fake.setTagReturnsOnCall = make(map[int]struct {
			result1 opentracing.Span
		})
	}
	fake.setTagReturnsOnCall[i] = struct {
		result1 opentracing.Span
	}{result1}
}

func (fake *FakeSpan) LogFields(fields ...log.Field) {
	fake.logFieldsMutex.Lock()
	fake.logFieldsArgsForCall = append(fake.logFieldsArgsForCall, struct {
		fields []log.Field
	}{fields})
	fake.recordInvocation("LogFields", []interface{}{fields})
	fake.logFieldsMutex.Unlock()
	if fake.LogFieldsStub != nil {
		fake.LogFieldsStub(fields...)
	}
}

func (fake *FakeSpan) LogFieldsCallCount() int {
	fake.logFieldsMutex.RLock()
	defer fake.logFieldsMutex.RUnlock()
	return len(fake.logFieldsArgsForCall)
}

func (fake *FakeSpan) LogFieldsArgsForCall(i int) []log.Field {
	fake.logFieldsMutex.RLock()
	defer fake.logFieldsMutex.RUnlock()
	return fake.logFieldsArgsForCall[i].fields
}

func (fake *FakeSpan) LogKV(alternatingKeyValues ...interface{}) {
	fake.logKVMutex.Lock()
	fake.logKVArgsForCall = append(fake.logKVArgsForCall, struct {
		alternatingKeyValues []interface{}
	}{alternatingKeyValues})
	fake.recordInvocation("LogKV", []interface{}{alternatingKeyValues})
	fake.logKVMutex.Unlock()
	if fake.LogKVStub != nil {
		fake.LogKVStub(alternatingKeyValues...)
	}
}

func (fake *FakeSpan) LogKVCallCount() int {
	fake.logKVMutex.RLock()
	defer fake.logKVMutex.RUnlock()
	return len(fake.logKVArgsForCall)
}

func (fake *FakeSpan) LogKVArgsForCall(i int) []interface{} {
	fake.logKVMutex.RLock()
	defer fake.logKVMutex.RUnlock()
	return fake.logKVArgsForCall[i].alternatingKeyValues
}

func (fake *FakeSpan) SetBaggageItem(restrictedKey string, value string) opentracing.Span {
	fake.setBaggageItemMutex.Lock()
	ret, specificReturn := fake.setBaggageItemReturnsOnCall[len(fake.setBaggageItemArgsForCall)]
	fake.setBaggageItemArgsForCall = append(fake.setBaggageItemArgsForCall, struct {
		restrictedKey string
		value         string
	}{restrictedKey, value})
	fake.recordInvocation("SetBaggageItem", []interface{}{restrictedKey, value})
	fake.setBaggageItemMutex.Unlock()
	if fake.SetBaggageItemStub != nil {
		return fake.SetBaggageItemStub(restrictedKey, value)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setBaggageItemReturns.result1
}

func (fake *FakeSpan) SetBaggageItemCallCount() int {
	fake.setBaggageItemMutex.RLock()
	defer fake.setBaggageItemMutex.RUnlock()
	return len(fake.setBaggageItemArgsForCall)
}

func (fake *FakeSpan) SetBaggageItemArgsForCall(i int) (string, string) {
	fake.setBaggageItemMutex.RLock()
	defer fake.setBaggageItemMutex.RUnlock()
	return fake.setBaggageItemArgsForCall[i].restrictedKey, fake.setBaggageItemArgsForCall[i].value
}

func (fake *FakeSpan) SetBaggageItemReturns(result1 opentracing.Span) {
	fake.SetBaggageItemStub = nil
	fake.setBaggageItemReturns = struct {
		result1 opentracing.Span
	}{result1}
}

func (fake *FakeSpan) SetBaggageItemReturnsOnCall(i int, result1 opentracing.Span) {
	fake.SetBaggageItemStub = nil
	if fake.setBaggageItemReturnsOnCall == nil {
		fake.setBaggageItemReturnsOnCall = make(map[int]struct {
			result1 opentracing.Span
		})
	}
	fake.setBaggageItemReturnsOnCall[i] = struct {
		result1 opentracing.Span
	}{result1}
}

func (fake *FakeSpan) BaggageItem(restrictedKey string) string {
	fake.baggageItemMutex.Lock()
	ret, specificReturn := fake.baggageItemReturnsOnCall[len(fake.baggageItemArgsForCall)]
	fake.baggageItemArgsForCall = append(fake.baggageItemArgsForCall, struct {
		restrictedKey string
	}{restrictedKey})
	fake.recordInvocation("BaggageItem", []interface{}{restrictedKey})
	fake.baggageItemMutex.Unlock()
	if fake.BaggageItemStub != nil {
		return fake.BaggageItemStub(restrictedKey)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.baggageItemReturns.result1
}

func (fake *FakeSpan) BaggageItemCallCount() int {
	fake.baggageItemMutex.RLock()
	defer fake.baggageItemMutex.RUnlock()
	return len(fake.baggageItemArgsForCall)
}

func (fake *FakeSpan) BaggageItemArgsForCall(i int) string {
	fake.baggageItemMutex.RLock()
	defer fake.baggageItemMutex.RUnlock()
	return fake.baggageItemArgsForCall[i].restrictedKey
}

func (fake *FakeSpan) BaggageItemReturns(result1 string) {
	fake.BaggageItemStub = nil
	fake.baggageItemReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeSpan) BaggageItemReturnsOnCall(i int, result1 string) {
	fake.BaggageItemStub = nil
	if fake.baggageItemReturnsOnCall == nil {
		fake.baggageItemReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.baggageItemReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeSpan) Tracer() opentracing.Tracer {
	fake.tracerMutex.Lock()
	ret, specificReturn := fake.tracerReturnsOnCall[len(fake.tracerArgsForCall)]
	fake.tracerArgsForCall = append(fake.tracerArgsForCall, struct{}{})
	fake.recordInvocation("Tracer", []interface{}{})
	fake.tracerMutex.Unlock()
	if fake.TracerStub != nil {
		return fake.TracerStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.tracerReturns.result1
}

func (fake *FakeSpan) TracerCallCount() int {
	fake.tracerMutex.RLock()
	defer fake.tracerMutex.RUnlock()
	return len(fake.tracerArgsForCall)
}

func (fake *FakeSpan) TracerReturns(result1 opentracing.Tracer) {
	fake.TracerStub = nil
	fake.tracerReturns = struct {
		result1 opentracing.Tracer
	}{result1}
}

func (fake *FakeSpan) TracerReturnsOnCall(i int, result1 opentracing.Tracer) {
	fake.TracerStub = nil
	if fake.tracerReturnsOnCall == nil {
		fake.tracerReturnsOnCall = make(map[int]struct {
			result1 opentracing.Tracer
		})
	}
	fake.tracerReturnsOnCall[i] = struct {
		result1 opentracing.Tracer
	}{result1}
}

func (fake *FakeSpan) LogEvent(event string) {
	fake.logEventMutex.Lock()
	fake.logEventArgsForCall = append(fake.logEventArgsForCall, struct {
		event string
	}{event})
	fake.recordInvocation("LogEvent", []interface{}{event})
	fake.logEventMutex.Unlock()
	if fake.LogEventStub != nil {
		fake.LogEventStub(event)
	}
}

func (fake *FakeSpan) LogEventCallCount() int {
	fake.logEventMutex.RLock()
	defer fake.logEventMutex.RUnlock()
	return len(fake.logEventArgsForCall)
}

func (fake *FakeSpan) LogEventArgsForCall(i int) string {
	fake.logEventMutex.RLock()
	defer fake.logEventMutex.RUnlock()
	return fake.logEventArgsForCall[i].event
}

func (fake *FakeSpan) LogEventWithPayload(event string, payload interface{}) {
	fake.logEventWithPayloadMutex.Lock()
	fake.logEventWithPayloadArgsForCall = append(fake.logEventWithPayloadArgsForCall, struct {
		event   string
		payload interface{}
	}{event, payload})
	fake.recordInvocation("LogEventWithPayload", []interface{}{event, payload})
	fake.logEventWithPayloadMutex.Unlock()
	if fake.LogEventWithPayloadStub != nil {
		fake.LogEventWithPayloadStub(event, payload)
	}
}

func (fake *FakeSpan) LogEventWithPayloadCallCount() int {
	fake.logEventWithPayloadMutex.RLock()
	defer fake.logEventWithPayloadMutex.RUnlock()
	return len(fake.logEventWithPayloadArgsForCall)
}

func (fake *FakeSpan) LogEventWithPayloadArgsForCall(i int) (string, interface{}) {
	fake.logEventWithPayloadMutex.RLock()
	defer fake.logEventWithPayloadMutex.RUnlock()
	return fake.logEventWithPayloadArgsForCall[i].event, fake.logEventWithPayloadArgsForCall[i].payload
}

func (fake *FakeSpan) Log(data opentracing.LogData) {
	fake.logMutex.Lock()
	fake.logArgsForCall = append(fake.logArgsForCall, struct {
		data opentracing.LogData
	}{data})
	fake.recordInvocation("Log", []interface{}{data})
	fake.logMutex.Unlock()
	if fake.LogStub != nil {
		fake.LogStub(data)
	}
}

func (fake *FakeSpan) LogCallCount() int {
	fake.logMutex.RLock()
	defer fake.logMutex.RUnlock()
	return len(fake.logArgsForCall)
}

func (fake *FakeSpan) LogArgsForCall(i int) opentracing.LogData {
	fake.logMutex.RLock()
	defer fake.logMutex.RUnlock()
	return fake.logArgsForCall[i].data
}

func (fake *FakeSpan) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	fake.finishWithOptionsMutex.RLock()
	defer fake.finishWithOptionsMutex.RUnlock()
	fake.contextMutex.RLock()
	defer fake.contextMutex.RUnlock()
	fake.setOperationNameMutex.RLock()
	defer fake.setOperationNameMutex.RUnlock()
	fake.setTagMutex.RLock()
	defer fake.setTagMutex.RUnlock()
	fake.logFieldsMutex.RLock()
	defer fake.logFieldsMutex.RUnlock()
	fake.logKVMutex.RLock()
	defer fake.logKVMutex.RUnlock()
	fake.setBaggageItemMutex.RLock()
	defer fake.setBaggageItemMutex.RUnlock()
	fake.baggageItemMutex.RLock()
	defer fake.baggageItemMutex.RUnlock()
	fake.tracerMutex.RLock()
	defer fake.tracerMutex.RUnlock()
	fake.logEventMutex.RLock()
	defer fake.logEventMutex.RUnlock()
	fake.logEventWithPayloadMutex.RLock()
	defer fake.logEventWithPayloadMutex.RUnlock()
	fake.logMutex.RLock()
	defer fake.logMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeSpan) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ opentracing.Span = new(FakeSpan)
